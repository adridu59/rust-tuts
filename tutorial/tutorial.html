<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A tutorial for the Rust programming language.">
  <meta name="author" content="Adrien T&eacute;tar">
  <meta name="keywords" content="rust, rustlang, rust programming language, rust tutorial">
  <title>Rust tutorials_NG</title>
  <link rel="stylesheet" href="../css/bootstrap.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/rust.css">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="shortcut icon" href="http://adridu59.github.io/rust-tuts/favicon.ico">
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
  <![endif]-->
</head>
<body class="container">
   <header>
     <ul class="nav nav-pills pull-right">
       <li><a href="../index.html">Home</a></li>
       <li class="active"><a href="index.html">Content</a></li>
       <li><a href="https://github.com/adridu59/rust-tuts/">Contribute</a></li>
     </ul>
     <h3 class="text-muted">&#36; <span style="color: #333">Rust tutorials</span></h3>
   </header>
<header>
<h1 class="title">Chapter 01</h1>
</header>
<section id="tell-me-more-about-rust" class="level1">
<h1>Tell me more about Rust!</h1>
<section id="a-bit-of-history" class="level2">
<h2>A bit of history</h2>
<p>Initially, <a href="http://www.rust-lang.org/">Rust</a> started out in 2006 as a personal project from Graydon Hoare—a language designer “by trade” to quote his own words. Developed in his free time during the first three years, Rust was then presented to his employers at Mozilla, which went on and started to actively support it. Indeed, Mozilla Research caught interest in it as something which could do away in the future with various recurrent bugs found in Gecko, Firefox’s rendering engine written in C++.</p>
<p>An original compiler has been written in <a href="http://caml.inria.fr/ocaml/index.fr.html">OCaml</a> until a bootstrapped compiler written in Rust itself could take over, in 2010. Right now the compilation process uses an <a href="http://llvm.org/">LLVM</a> backend (which you might have seen in action inside <a href="http://clang.llvm.org/">Clang</a>).</p>
</section>
<section id="the-goodness" class="level2">
<h2>The Goodness</h2>
<p>So what is so good about Rust? We talked about C++ right at the beginning and you might think that since Mozilla is actively leading its development, it should actually have some significant advantages compared to it.</p>
<p>First, what are people looking for when they want to use C++?</p>
<ul>
<li>A <a href="http://en.wikipedia.org/wiki/System_programming_language">System programming language</a>, which means it does not compromise on performance and allows for low-level access to the available resources (pointers, manual memory management, etc.)<br /></li>
<li>A language with a fairly high-level of abstraction and a large feature-set (OO-programming is one of them) that stays fast and has broad compatibility</li>
</ul>
<p>Now, what are the main features that Rust brings on top of that?</p>
<ul>
<li>Safety (and mostly: safe pointer types thanks to a <a href="http://static.rust-lang.org/doc/master/tutorial.html#boxes">very efficient memory model</a>, no void* heresy<sup>◊</sup>, no use-after-free, mem leaks,…)<br /></li>
<li>Native actor-based concurrency inspired from <a href="http://www.erlang.org/">Erlang</a>. This is a big deal for today’s programming languages with the rise of multicore processors; in fact, some sort of multithreading is already there on C++11 (2011) and will probably get extended in C++14. Actually, the actor implementation of multithreading consists of explicitly sending message from a lightweight thread (<code>chan</code>) and receiving it from another (<code>port</code>); it is a great safety/efficiency compromise<br /></li>
<li>Inspirations from <a href="http://www.haskell.org/">Haskell</a> and <a href="http://caml.inria.fr/ocaml/index.fr.html">OCaml</a>, not only for the functional programming paradigm but also for the type classes (<code>type</code>, <code>impl</code>)<br /></li>
<li>Some easier to use functionalities from Python —that being said, Rust does not compromise on safety: it has static typing (with type inference!)<br /></li>
<li>Optional tracing-GC (WIP) —the <code>std::gc::Gc</code> type recently landed on mainline</li>
</ul>
<p>Rust does not try to be a new fancy thing; rather, it builds up on top of proven useful technology and merges features from some existings languages, noticeably: Erlang’s green threads, Haskell trait system and overall functional programming elements of a few languages (it has pattern matching!), some syntax sugar from Python (the <code>range</code> iterator is one of them) and it also resurrects a few features from some American research languages developed in the 90s, amongst others.<br />As you can see, along with some features that definitely set it in today’s rollup of programming languages, Rust is also the result of a true willingness to reuse concepts from the rich history of programming languages, rather than building up the wheel over again. ;) ~ as you might have seen, that’s partly where the name “Rust” comes from!</p>
<blockquote>
<p>I was fiddling with a number of names. Primarily it’s named after the <a href="https://en.wikipedia.org/wiki/Rust_%28fungus%29">pathogenic fungi</a> which are just amazing multi-lifecycle, multi-host parasites, fascinating creatures.</p>
<p>But the name “rust” has other nice features. It fits with our theme of being “close to the metal” and “using old well-worn language technology”. It’s also a substring of “trust” and “robust”. What’s not to like?</p>
<p>— Graydon Hoare</p>
</blockquote>
<p>Actually, Mozilla is already using it in an experimental browser rendering engine that is being developed simultaneously to Rust and is at the core of the team’s pragmatic development approach, just like <a href="http://dlang.org/">D</a>’s—that is, the developers implement features and sometimes change them based on their experience with it; besides, they also take feedback (and contributions!) from the community.<br />Remember, C—today’s most successful language—has been built in concert with the UNIX OS, allowing adaptations from what happened during the OS development process. Right now, Rust is still in alpha state which means that developers can still make breaking changes to the API (but not to worry, it is converging towards a stable state which will ultimately happen in 1.0).</p>
<p>There have been other attempts at providing such a new System programming language (e.g. <a href="http://dlang.org/">D</a>, <a href="http://nimrod-lang.org/">Nimrod</a>)—Go also gets mentioned sometimes but it has been developed for apps/webapps and is oriented towards simplicity and fast compilation-speed.<br />Right now, it looks like Rust has a big chance to set itself apart because:</p>
<ul>
<li>it focuses on safety without compromising performance (D requires GC for safety, and Nimrod does not ensure thread safety), it has low-level features but also lots of sugar for the developer<br /></li>
<li>it is pretty innovative! —seeing how it reuses a lot of features that have been developed independently, but make sense together<br /></li>
<li>it is backed by Mozilla, not bad if you are trying to set a standard!</li>
</ul>
</section>
<section id="appendix-elaborating-on-c-and-safety" class="level2">
<h2>Appendix: Elaborating on C++ and safety</h2>
<p><sup>◊</sup>You might think: why were these even allowed in the first place? To quote Tony Hoare, the <code>null_ptr</code> precursor:</p>
<blockquote>
<p>I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>— Tony Hoare</p>
</blockquote>
<p>C++ is a mixed-breed: it has been developed from the beginning to build up on top of C with new features that were emerging in the field of programming. Today, it is one of the <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">Top Five languages</a> because it has been fast at a higher level of abstraction (also complexity!) than the others.<br />Looking back, we realized that the time spared by relaxed programming APIs was often creating much bigger problems down the road—because it is always less time consuming and more convenient to just avoid these programming derps than debugging your program down the road.</p>
<p>Rust tries to ensure safety with some additional syntax markup (which actually makes you to think unambiguously about your desired behavior) that allows for a way more fine-grained static analysis by the compiler and can lead to additional compiler optimizations—indeed, some unsafe code that would pass as valid in most of today’s most used languages would get caught at compile-time in Rust. Instructions that are not safe or cannot be statically checked will have to be located inside an <code>unsafe</code> code block (that is mostly for the FFI, that allows you to link your programs to C).</p>
</section>
<section id="appendix-elaborating-on-servo" class="level2">
<h2>Appendix: Elaborating on Servo</h2>
<p>What is <a href="https://github.com/mozilla/servo">Servo</a>? Well—nothing to do with mechanics: it is Mozilla’s experimental browser rendering engine.</p>
<p>So, in a way, you could say that it’s their biggest <a href="http://people.mozilla.org/~roc/Samsung/MozillaRustAndServo.pdf#10">hope</a> and biggest motivation for supporting Rust’s development. Safety. Parallelism. (And Performance.)<br />Its development started in early-2012 (they like contributions too!) and it is evolving along with Rust.</p>
<p>Servo is built on a modular architecture and each engine component is separated from the other in an effort to have parallelized and easy-to-maintain code. Since April 2013, Mozilla and Samsung <a href="https://blog.mozilla.org/blog/2013/04/03/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/">are collaborating</a> in the project development.</p>
<p>Note that right now, Mozilla has no plans to integrate Servo onto Firefox, ie. it is as of now a research project and is still in early stages of development. BTW, Servo <a href="https://github.com/mozilla/servo/wiki/Acid-test-features">passed Acid1</a> recently!</p>
<p>% Chapter 02</p>
</section>
</section>
<section id="few-things-you-should-know" class="level1">
<h1>Few things you should know</h1>
<p>The Rust API is frequently evolving. While the use of the 0.8 release is recommended on Windows (unless you’re willing to <a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#quick-steps-for-windows-environment-setup)">build it</a>), this tutorial will be aimed at current master which has the latest language contents.<br />Note that much of the “standard” features are pretty much stabilized and shouldn’t change much. If you have any concern related to the language or its syntax, just <a href="http://client01.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">jump on IRC</a> and ask the others!</p>
</section>
<section id="installing-rust" class="level1">
<h1>Installing Rust</h1>
<section id="windows" class="level2">
<h2>Windows</h2>
<p>Checkout the <a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#quick-steps-for-windows-environment-setup)">building instructions</a>.<br />Note: <code>mingw-w64</code> support is incoming on latest trunk.</p>
<p>If you’re not willing to go through these steps, just download the <a href="http://static.rust-lang.org/dist/rust-0.8-install.exe">0.8 installer</a>.</p>
</section>
<section id="mac-os-x" class="level2">
<h2>Mac OS X</h2>
<p>The installation process on Mac OS is fairly easy with the <a href="http://brew.sh/">Homebrew package manager</a>, for the latest trunk:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">brew</span> install --HEAD rust</code></pre>
<p>And to get the latest release:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">brew</span> install rust</code></pre>
</section>
<section id="linux" class="level2">
<h2>Linux</h2>
<p>Okay Linux users, let’s build the beast:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mozilla/rust.git
<span class="kw">cd</span> rust
<span class="kw">./configure</span>
<span class="kw">make</span>
<span class="kw">sudo</span> make install</code></pre>
<p>And for the 0.8 release, use these sources:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">curl</span> -O http://static.rust-lang.org/dist/rust-0.8.tar.gz
<span class="kw">tar</span> -xzf rust-0.8.tar.gz
<span class="kw">cd</span> rust-0.8
<span class="kw">./configure</span>
<span class="kw">make</span>
<span class="kw">sudo</span> make install</code></pre>
<p>Note that there are repositories with nightly packages for <a href="http://pkgbuild.com/~thestinger/">Arch</a> and <a href="https://launchpad.net/~hansjorg/+archive/rust">Ubuntu</a>.</p>
</section>
</section>
<section id="get-your-code-editor-ready" class="level1">
<h1>Get your code editor ready</h1>
<p>You are about to write your first Rust program; first, just create a <code>.rs</code> file with your favorite text editor. You are going to build it with <code>rustc</code>, the Rust compiler.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># create a new file</span>
<span class="kw">touch</span> hello.rs
<span class="co"># now compile it...</span>
<span class="kw">rustc</span> hello.rs
<span class="co"># ...and run!</span>
<span class="kw">./hello</span></code></pre>
<p>Note: on Windows, you will have to call <code>rustc.exe</code> for now due to issue <a href="https://github.com/mozilla/rust/issues/3319">#3319</a>.</p>
<p>BTW, you can get syntax highlighting for <a href="https://github.com/mozilla/rust/tree/master/src/etc/vim">vim</a>, <a href="https://github.com/mozilla/rust/tree/master/src/etc/gedit">gedit</a> or <a href="https://github.com/mozilla/rust/tree/master/src/etc%20%%20Chapter%2003">other highlighting solutions</a> on the main repo.</p>
</section>
<section id="and-so-it-begins" class="level1">
<h1>And so it begins!</h1>
<section id="the-starting-point" class="level2">
<h2>The starting point</h2>
<p>So, you are learning a programming language… you know what this means?</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    println(<span class="st">&quot;Hello World!&quot;</span>);
}</code></pre>
<p>Yes, it is that simple. As you can see, functions are declared using the generic <code>fn</code> keyword (for the C habitués, the return type—if any—is specified as in ML, after an ASCII arrow e.g. <code>fn random() -&gt; int { ... }</code>).</p>
<p>To out your own, save this code snippet and call <code>rustc</code>!</p>
<p>Now let’s try something funny:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> out = <span class="st">&quot;Hello World!&quot;</span>;
    <span class="kw">for</span> c in out.chars() {
        <span class="co">/* spawn concurrent tasks! */</span>
        <span class="kw">do</span> spawn {
            print!(<span class="st">&quot;{}&quot;</span>, c);
        }
    }
}</code></pre>
</section>
<section id="the-looping-point" class="level2">
<h2>The looping point</h2>
<p>First, notice the loop syntax: for (each) <code>element</code> in <code>container</code>, as in Python. <code>element</code> should be <code>_</code> if you are not using it (no referencing).<br />Here, we make use of Rust’s functional paradigm by using <code>.chars()</code> to iterate over the chars of our string (it used to be <code>.iter()</code>): our iterator will successively host each char of the string, so we can print those directly.<br />What if we wanted to simply iterate a said number of times? Well, for that we have a special container, the <code>range()</code> iterator.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i in range(n) <span class="co">/// Creates an iterator that will do `n` times, from 0 to n-1</span>
<span class="kw">for</span> _ in range(<span class="dv">1</span>,n+<span class="dv">1</span>) <span class="co">/// This one will go from 1 to n</span>
<span class="co">/// Notice the joker `_`, that&#39;s if we don&#39;t want to reference the iterator for use in the loop</span></code></pre>
<p>Now, before first looking at the type syntax itself, let’s look at the output:</p>
<pre><code>Hllo World!
e</code></pre>
<p>Well, we did <code>spawn</code> a few concurrent tasks. Things are done asynchronously, which means that one of the tasks may unpredictibly end-up before the other. Anyways, spawning threads to print out the letters of a sentence is pretty silly!</p>
<p>BTW, speaking of loops: <code>while</code> uses the usual syntax: <code>while &lt;condition&gt; {}</code> and the <code>loop</code> keyword is to be preferred to <code>while true {}</code>, which is essentially a hack.<br />Rust doesn’t have the <code>do {} while;</code> syntax, we just use a <code>while</code> with a condition instead.</p>
</section>
<section id="variables-and-types" class="level2">
<h2>Variables and types</h2>
<p>As you can see, variables are declared via the <code>let</code> keyword and you do not need to specify the type (ML anyone?) because Rust has type inference, which means that the variable type is determined automatically at <em>compile time</em> —not to be confused with dynamic typing, as in Python, where the variable type gets determined at run-time and can be modified.<br />Let’s look at some of the primitive types:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = <span class="dv">3</span>; <span class="co">// considered as `int` by default</span>
<span class="kw">let</span> b = <span class="st">&quot;code&quot;</span>; <span class="co">// that would be an `str` - string</span>
<span class="kw">let</span> c = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// and that&#39;s a `vec` - array</span>
<span class="kw">let</span> d = <span class="kw">true</span>; <span class="co">// bool</span></code></pre>
<p>Rust variables are immutable by default in order to avoid some common errors, so you need to append the mutable <code>mut</code> keyword to <code>let</code> in order to reassign a value. The compiler will warn you if there are unused <code>mut</code>s in your code.<br />BTW: unlike C for example, Rust does not let you edit an immutable variable via its pointer.</p>
<p>Speaking of type assignment, you can force the use of a particular type:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a: <span class="kw">uint</span> = <span class="dv">3</span>; <span class="co">// unsigned int</span>
<span class="kw">let</span> a = <span class="dv">3u</span>; <span class="co">// same as the last line, this is a short variable suffix for convenience</span>

<span class="kw">let</span> <span class="kw">mut</span> n = <span class="dv">3</span>; <span class="co">// `n` is supposedly an `int` from here...</span>
n = <span class="dv">5u</span>; <span class="co">// but is assigned an `uint` here, so the compiler will consider `n` as an `uint`</span>
<span class="kw">let</span> <span class="kw">mut</span> h = ~[]; <span class="co">// unknown-type `vec` - won&#39;t compile as such</span>
h = [<span class="dv">1u</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// a `vec` of `uint`s</span></code></pre>
<p>There are other suffixes like <code>i32</code> (32-bits integer), <code>i64</code>, <code>f32</code> (32-bit float), <code>f64</code>… the empty type is called nil and annotated <code>()</code>. But remember, you cannot change the type of a variable during it’s lifetime—static typing!</p>
<p>Functions need explicit parameters and return types. Let’s look at one:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> abs(x: <span class="kw">int</span>) -&gt; <span class="kw">uint</span> {
    <span class="kw">if</span> x &gt; <span class="dv">0</span> { x }
    -x
}

<span class="kw">fn</span> square(x: <span class="kw">int</span>) -&gt; <span class="kw">int</span> {
    x*x
}

<span class="kw">fn</span> main() {
    <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">3u</span>;
    <span class="co">/* Now, calculate the square. */</span>
    x = square(x);
    println(x);
}</code></pre>
<p>Ok, but this code will warn because we are passing an unsigned int to a function that takes int as parameter; if we were in a situation where we cannot change the type annotation, we would have to just cast the value of <code>x</code>. Rust has 2 ways of casting: <code>x.to_targetType();</code> and <code>x as targetType;</code>. The <code>to_*</code> method is to be preferred for performance.<br />Additionally, there’s a third way of casting, <a href="https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes#cast-naming-conventions">into</a>.</p>
<p>In Rust, instructions that do not end with semicolons are expressions (not statements), meaning that they will return their value to the higher-level block.<br />This allows you no only to return from a function but—for example to allocate a value based on a test’s result. This is valid Rust code:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hype =
    <span class="kw">if</span> cake == <span class="st">&quot;KitKat&quot;</span> {
        <span class="dv">10</span>
    } <span class="kw">else</span> <span class="kw">if</span> cake == <span class="st">&quot;Jelly Bean&quot;</span> {
        <span class="dv">7</span>
    } <span class="kw">else</span> {
        <span class="dv">5</span>
    };</code></pre>
</section>
<section id="a-last-note-on-types-and-prints" class="level2">
<h2>A last note on types and prints</h2>
<p>Let’s go back on a similar example as with the <code>spawn</code>s before, this time using a <code>vec</code> of <code>char</code>s:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> out = [<span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>];
    <span class="kw">for</span> c in out.iter() { <span class="co">// iterate over `out`</span>
        print!(<span class="st">&quot;{}&quot;</span>, c);
    }
}</code></pre>
<p>Strings and pack of char’s are essentially the same in memory, but strings have specific methods and are plain better at handling a bunch of <code>char</code>s.<br />FYI, there’s a small article that talks about types in Rust and has interesting facts, <a href="http://jvns.ca/blog/2013/12/02/types-in-rust/">check it out</a>!</p>
<p>So Rust has a few printing functions, the standards <code>print</code>/<code>println</code> which want a <code>string</code> as input but also <code>print!</code>/<code>println!</code> macros (or syntax-entensions—ending with <code>!</code>) which will format-print your variables marked as <code>{}</code> and passed as arguments into strings.<br />BTW, you can <a href="http://static.rust-lang.org/doc/master/std/fmt/index.html">specify the type manually</a>, e.g. <code>{:u}</code> says this is an unsigned integer literal.</p>
</section>
<section id="appendix-going-back-on-macros" class="level2">
<h2>Appendix: Going back on macros</h2>
<p>About the macros: they are syntax extensions in the sense that they are like scripts, but are evaluated at compile-time. So they serve only the developer by simplifying/automating things.<br />Think about <code>#define</code> in C, but much more powerful. BTW, macros have a few syntax elements of their own, for example, variables get referenced as <code>$var</code>.</p>
<p>Not elaborating further on it for now but you can have a look at the <a href="http://static.rust-lang.org/doc/master/tutorial-macros.html">mainline macro tutorial</a> for some code examples.</p>
</section>
<section id="appendix-code-comments" class="level2">
<h2>Appendix: Code comments</h2>
<p>You will probably start quickly adding comments to your code (well, you should anyways!) so let’s speak about that now.<br />Rust uses C-style comments: inline with <code>// yuck!</code> and multiline with <code>/* yuck! */</code>. Rust also has a built-in doc generator (librustdoc); doc comments get referenced as such with either <code>///</code> or <code>/** **/</code>; check out how it works for the <a href="http://static.rust-lang.org/doc/master/std/index.html">standard library</a>!</p>
<p>You can learn more about rustdoc <a href="https://github.com/mozilla/rust/wiki/Doc-using-rustdoc">here</a>.</p>
</section>
<section id="appendix-on-functional-programming" class="level2">
<h2>Appendix: on functional programming</h2>
<p>The functional capatibilities of Rust are powerful as it makes use of type-specific operations.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> my_vec = [-<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>];
<span class="kw">for</span> i in my_vec.iter().invert() {
    print(i.to_str());
}</code></pre>
</section>
</section>
<footer>
<p>A Rust community project. [&copy;] <span class="pull-right"><a href="http://www.reddit.com/r/rust">Reddit</a> &middot; <a href="http://www.rust-lang.org/">Rustlang</a></span></p>
</footer>
</body>
</html>
