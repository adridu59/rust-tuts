<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A tutorial for the Rust programming language.">
  <meta name="author" content="Adrien T&eacute;tar">
  <meta name="keywords" content="rust, rustlang, rust programming language, rust tutorial">
  <title>Rust tutorials_NG</title>
  <link rel="stylesheet" href="../css/bootstrap.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/rust.css">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="shortcut icon" href="http://adrientetar.github.io/rust-tuts/favicon.ico">
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
  <![endif]-->
</head>
<body class="container">
   <header>
     <ul class="nav nav-pills pull-right">
       <li><a href="../index.html">Home</a></li>
       <li class="active"><a href="index.html">Content</a></li>
       <li><a href="https://github.com/adrientetar/rust-tuts/">Contribute</a></li>
     </ul>
     <h3 class="text-muted">&#36; <span style="color: #333">Rust tutorials</span></h3>
   </header>
<header>
<h1 class="title">Rust tutorials</h1>
</header>
<section id="tell-me-more-about-rust" class="level1">
<h1>Tell me more about Rust!</h1>
<section id="a-bit-of-history" class="level2">
<h2>A bit of history</h2>
<p>Initially, <a href="http://www.rust-lang.org/">Rust</a> started out in 2006 as a personal project from Graydon Hoare – a language designer “by trade” to quote his own words. Developed in his free time during the first three years, Rust was then presented to his employers at Mozilla, which went on and started to actively support it. Indeed, Mozilla Research caught interest in it as something which could do away in the future with various recurrent bugs found in Gecko, Firefox’s rendering engine written in C++.</p>
<p>An original compiler has been written in <a href="http://caml.inria.fr/ocaml/index.fr.html">OCaml</a> until a bootstrapped compiler written in Rust itself could take over, in 2010. Right now the compilation process uses an <a href="http://llvm.org/">LLVM</a> backend (which you might have seen in action inside <a href="http://clang.llvm.org/">Clang</a>).</p>
</section>
<section id="the-goodness" class="level2">
<h2>The Goodness</h2>
<p>So what is so good about Rust? We talked about C++ right at the beginning and you might think that since Mozilla is actively leading its development, it should actually have some significant advantages compared to it.</p>
<p>First, what are people looking for when they want to use C++?</p>
<ul>
<li>A <a href="http://en.wikipedia.org/wiki/System_programming_language">System programming language</a>, which means it does not compromise on performance and allows for low-level access to the available resources (pointers, manual memory management, etc.)</li>
<li>A language with a fairly high-level of abstraction and a large feature-set (<a href="http://en.wikipedia.org/wiki/Object_oriented_programming">OO programming</a> is one of them) that stays fast and has broad compatibility</li>
</ul>
<p>Now, what are the main features that Rust brings on top of that?</p>
<ul>
<li>Safety (and mostly: safe pointer types thanks to a <a href="http://static.rust-lang.org/doc/master/tutorial.html#boxes">very efficient memory model</a>, no void* heresy, no use-after-free, mem leaks,…)</li>
<li>Native actor-based concurrency inspired from <a href="http://www.erlang.org/">Erlang</a>. This is a big deal for today’s programming languages with the rise of multicore processors; in fact, some sort of multithreading is already there on C++11 (2011) and will probably get extended in C++14. Actually, the actor implementation of multithreading consists of explicitly sending message from a lightweight thread (<code>chan</code>) and receiving it from another (<code>port</code>); it is a great safety/efficiency compromise. Rust allows the use of either green (M:N) or native (1:1) threads.</li>
<li>Inspirations from <a href="http://www.haskell.org/">Haskell</a> and <a href="http://caml.inria.fr/ocaml/index.fr.html">OCaml</a>, not only for the functional programming paradigm but also for the type classes (<code>trait</code>, <code>impl</code>)</li>
<li>Some programmers friendly features from Python – that being said, Rust does not compromise on performance: it has static typing (with type inference!)</li>
<li>As mentioned before, Rust has a precise-caliber typesystem ensuring its memory safety at compile-time, allowing programmers to abandon the overhead of GC in most cases.<br /> However, Rust will pack an optional tracing-GC (WIP) upon release, which will allow to run it isolated inside a thread (so that both low-latency uses and a garbage collector can be combined on different threads). Note that right now, the <a href="http://static.rust-lang.org/doc/master/std/gc/struct.Gc.html"><code>Gc</code> type</a> in the language is just a wrapper around a reference counting pointer</li>
</ul>
<p>As you can see, Rust does not try to be a new fancy thing; rather, it builds up on top of proven useful technology and merges features from some existings languages, noticeably: Erlang’s green threads, Haskell trait system and overall functional programming elements of a few languages (it has pattern matching!), some syntax sugar from Python (the <code>range</code> iterator is one of them) and it also resurrects a few features from some American research languages developed in the 80s, amongst others.<br />As you can see, along with some features that definitely set it in today’s rollup of programming languages, Rust is also the result of a true willingness to reuse concepts from the rich history of programming languages, rather than building up the wheel over again. ;) ~ as you might have seen, that’s partly where the name “Rust” comes from!</p>
<blockquote>
<p>I was fiddling with a number of names. Primarily it’s named after the <a href="http://en.wikipedia.org/wiki/Rust_%28fungus%29">pathogenic fungi</a> which are just amazing multi-lifecycle, multi-host parasites, fascinating creatures.</p>
<p>But the name “rust” has other nice features. It fits with our theme of being “close to the metal” and “using old well-worn language technology”. It’s also a substring of “trust” and “robust”. What’s not to like?</p>
<p>— Graydon Hoare</p>
</blockquote>
<p>Actually, Mozilla is already using it in an experimental browser rendering engine that is being developed simultaneously to Rust and is at the core of the team’s pragmatic development approach, just like <a href="http://dlang.org/">D</a>’s – that is, the developers implement features and sometimes change them based on their experience with it; besides, they also take feedback (and contributions!) from the community.<br />Remember, C – today’s most successful language – has been built in concert with the UNIX OS, allowing adaptations from what happened during the OS development process. Right now, Rust is still in alpha state which means that developers can still make breaking changes to the API (but not to worry, it is converging towards a stable state which will ultimately happen in 1.0).</p>
<p>There have been other attempts at providing such a new System programming language (e.g. <a href="http://dlang.org/">D</a>, <a href="http://nimrod-lang.org/">Nimrod</a>) – Go also gets mentioned sometimes but it has been developed for apps/webapps and is more oriented towards simplicity and fast compilation-speed. Right now, it looks like Rust has a big chance to set itself apart because:</p>
<ul>
<li>It focuses on safety without compromising performance (D requires GC for safety, and Nimrod does not ensure thread safety), it has low-level features but also lots of sugar for the developer (the syntax is modern and not overly verbose)</li>
<li>It is pretty innovative, seeing how it reuses a lot of features that have been developed independently, but make sense together</li>
<li>It is backed by Mozilla, not bad if you are trying to set a standard!</li>
</ul>
</section>
<section id="appendix-elaborating-on-c-and-safety" class="level2">
<h2>Appendix: Elaborating on C++ and safety</h2>
<p>You might think: why were these even allowed in the first place? To quote Tony Hoare, the <code>null_ptr</code> precursor:</p>
<blockquote>
<p>I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>— Tony Hoare</p>
</blockquote>
<p>C++ is a mixed breed: it has been developed from the beginning to build up on top of C with new features that were emerging in the field of programming. Today, it is one of the <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">Top Five languages</a> because it has been fast at a higher level of abstraction (also complexity!) than the others.<br />Looking back, we realized that the time spared by relaxed programming APIs was often creating much bigger problems down the road – because it is always less time consuming and more convenient to just avoid these programming derps than debugging your program afterwards.</p>
<p>Rust tries to ensure safety with some additional syntax markup (which actually makes you to think unambiguously about your desired behavior) that allows for a way more fine-grained static analysis by the compiler and can lead to additional compiler optimizations – indeed, some unsafe code that would pass as valid in most of today’s most-used languages would get caught at compile-time in Rust. Instructions that are not safe or cannot be statically checked will have to be located inside an <code>unsafe</code> code block (that is mostly for the FFI, which allows you to link your programs to C).</p>
</section>
<section id="appendix-elaborating-on-servo" class="level2">
<h2>Appendix: Elaborating on Servo</h2>
<p>What is <a href="https://github.com/mozilla/servo">Servo</a>? Well – nothing to do with mechanics: it is Mozilla’s experimental browser rendering engine.</p>
<p>So, in a way, you could say that it’s their biggest <a href="http://people.mozilla.org/~roc/Samsung/MozillaRustAndServo.pdf#10">hope</a> and biggest motivation for supporting Rust’s development. Safety. Parallelism. (And Performance.) Its development started in early-2012 (they like contributions too!) and it is evolving along with Rust.</p>
<p>Servo is built on a modular architecture and each engine component is separated from the other in an effort to have parallelized and easy-to-maintain code. Since April 2013, Mozilla and Samsung <a href="https://blog.mozilla.org/blog/2013/04/03/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/">are collaborating</a> in the project development.</p>
<p>Note that right now, Mozilla has no plans to integrate Servo onto Firefox, i.e., it is as of now a research project and is still in early stages of development. BTW, Servo <a href="https://github.com/mozilla/servo/issues/266">passed Acid1</a> recently!</p>
</section>
</section>
<section id="few-things-you-should-know" class="level1">
<h1>Few things you should know</h1>
<p>The Rust API is frequently evolving (read: improving), so this tutorial will be aimed at current master which has the latest language contents.<br />Note that most of the “standard” features are pretty much stabilized and should not change much. You can choose to use the latest release, but as it gets older, there will probably be numerous changes onto the latest trunk. If you have any concern related to the language or its syntax, just <a href="http://client01.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">jump on IRC</a> and ask the others!</p>
<p>The latest release is Rust 0.9, released on January 9th 2014.</p>
<section id="installing-rust" class="level2">
<h2>Installing Rust</h2>
<section id="windows" class="level3">
<h3>Windows</h3>
<p>You can get <a href="https://www.nuget.org/packages/Rust/">snapshot builds</a> for Windows through the NuGet <a href="http://docs.nuget.org/docs/start-here/installing-nuget#Command-Line_Utility">Package Manager console</a>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Install-Package</span> Rust</code></pre>
<p>Or have a look at the <a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#quick-steps-for-windows-environment-setup)">build instructions</a> if you want to build it yourself.<br /><strong>Note: <code>mingw-w64</code> should fix a few things compared to the regular <code>mingw</code> (it </strong>works on both 32- and 64-bit systems, despite the name).</p>
<p>If you are not willing to go through these steps, just download the <a href="https://github.com/mozilla/rust/wiki/Using-Rust-on-Windows">0.9 release</a>.</p>
</section>
<section id="mac-os-x" class="level3">
<h3>Mac OS X</h3>
<p>The installation process on Mac OS is fairly easy using the <a href="http://brew.sh/">Homebrew package manager</a>; for the latest trunk, run:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">brew</span> install --HEAD rust</code></pre>
<p>And to get the latest release:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">brew</span> install rust</code></pre>
</section>
<section id="linux" class="level3">
<h3>Linux</h3>
<p>Okay Linux users, let’s build the beast:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mozilla/rust.git
<span class="kw">cd</span> rust
<span class="kw">./configure</span>
<span class="kw">make</span>
<span class="kw">sudo</span> make install</code></pre>
<p>And for the 0.9 release, use these sources:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">curl</span> -O http://static.rust-lang.org/dist/rust-0.9.tar.gz
<span class="kw">tar</span> -xzf rust-0.9.tar.gz
<span class="kw">cd</span> rust-0.9
<span class="kw">./configure</span>
<span class="kw">make</span>
<span class="kw">sudo</span> make install</code></pre>
<p>Note that there are repositories with nightly packages for <a href="http://pkgbuild.com/~thestinger/">Arch</a>, <a href="http://dummdida.blogspot.de/2013/05/mozillas-rust-in-fedoras-ppa-copr.html">Fedora</a> and <a href="https://launchpad.net/~hansjorg/+archive/rust">Ubuntu</a>.</p>
</section>
</section>
<section id="get-your-code-editor-ready" class="level2">
<h2>Get your code editor ready</h2>
<p>You are about to write your first Rust program; just create a <code>.rs</code> file with your favorite text editor. It gets built with <code>rustc</code>, the Rust compiler.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># create a new file</span>
<span class="kw">touch</span> hello.rs
<span class="co"># now compile it...</span>
<span class="kw">rustc</span> hello.rs
<span class="co"># ...and run!</span>
<span class="kw">./hello</span></code></pre>
<p>Using the <code>-O</code> switch will add the default optimization level to the code.</p>
<p>BTW, you can get syntax highlighting for <a href="https://github.com/mozilla/rust/tree/master/src/etc/vim">vim</a>, <a href="https://github.com/mozilla/rust/tree/master/src/etc/gedit">gedit</a> or <a href="https://github.com/mozilla/rust/tree/master/src/etc">other highlighting solutions</a> on the main repo.</p>
</section>
</section>
<section id="and-so-it-begins" class="level1">
<h1>And so it begins!</h1>
<section id="the-starting-point" class="level2">
<h2>The starting point</h2>
<p>So, you are learning a programming language… you know what that means?</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="ot">println!</span>(<span class="st">&quot;Hello World!&quot;</span>);
}</code></pre>
<p>Yes, it is that simple. As you can see, functions are declared using the generic <code>fn</code> keyword and for the C habitués, the return type – if any – is specified as in ML, after an ASCII arrow, e.g., <code>fn random() -&gt; int { ... }</code>.</p>
<p>To try it out on your own, save this code snippet and call <code>rustc</code>!</p>
<p>Now let’s try something funny:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> out = <span class="st">&quot;Hello World!&quot;</span>;
    <span class="kw">for</span> c in out.chars() {
        <span class="co">/* spawn concurrent tasks! */</span>
        spawn(proc() {
            <span class="ot">print!</span>(<span class="st">&quot;{}&quot;</span>, c);
        });
    }
}</code></pre>
</section>
<section id="the-looping-point" class="level2">
<h2>The looping point</h2>
<p>First, notice the loop syntax: for (each) <code>element</code> in <code>container</code>, as in Python.<br />Here, we make use of Rust’s iterator type with <code>.chars()</code> to successively host each char of the string (it used to be <code>.iter()</code>) so we can print those directly.</p>
<p>What if we wanted to simply iterate a said number of times? Well, for that we have a special container, the <code>range()</code> iterator.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Yields an iterator that will do `n` times, from 0 to n-1</span>
<span class="co">// Note: using just `range(n)` is not possible just yet</span>
<span class="kw">for</span> i in range(<span class="dv">0</span>, n) {}
<span class="co">// This one will go from 1 to n</span>
<span class="kw">for</span> _ in range(<span class="dv">1</span>, n+<span class="dv">1</span>)</code></pre>
<p>As you can see, <code>range()</code> has exclusive upper bound, to be in line with 0-based indexing.<br />Notice the wildcard <code>_</code> in the second example, which is used if we don’t want to reference the iterator for use as a local variable in the loop.</p>
<p>BTW, let’s look at the conditional <code>while</code> loop right now:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> cake = have_my_cake();
<span class="kw">while</span> cake &gt; <span class="dv">0</span> {
    cake -= <span class="dv">1</span>; <span class="co">// eat it</span>
}</code></pre>
<p>Note that for infinite loops, the <code>loop</code> keyword is to be preferred to <code>while true { }</code> (which is essentially a hack). Also, Rust doesn’t have the <code>do { } while;</code> syntax; you can just use a <code>loop</code> with a breaking condition instead – <code>break</code> will exit a loop while <code>continue</code> will jump to the next iteration.</p>
<p>Now, before looking at the type syntax itself, let’s look at the output:</p>
<pre><code>Hllo World!
e</code></pre>
<p>Well, we did <code>spawn</code> a few concurrent tasks. Things are done asynchronously, which means that one of the tasks may unpredictably end up before the other. Anyways, spawning threads to print out the letters of a sentence is pretty silly!</p>
<p><strong>Note:</strong> <code>proc()</code> is a one-shot closure, the latter being a nested function that captures its surrounding environment (i.e. one can access the variables of the containing namespace).</p>
</section>
<section id="types-and-assignment" class="level2">
<h2>Types and assignment</h2>
<p>As you can see, variables are declared via the <code>let</code> keyword and type specification is optional (~ML) because Rust has a type inference mechanism, which means that the variable type is determined at <em>compile time</em> – not to be confused with dynamic typing, as in Python, where the variable type is managed at run-time and can be dynamically modified.</p>
<p><strong>Note: the convention is that variables and function names are_lowercase while </strong>type names are CamelCase.</p>
<p>Let’s have a look at some of the primitive types:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = <span class="dv">3</span>; <span class="co">// considered as `int` by default</span>
<span class="kw">let</span> b = <span class="st">&quot;code&quot;</span>; <span class="co">// that would be an `str` - string</span>
<span class="kw">let</span> c = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// and that&#39;s a `vec` - array (of fixed-length)</span>
<span class="kw">let</span> d = <span class="kw">true</span>; <span class="co">// bool</span></code></pre>
<p>Rust variables are immutable by default in order to avoid some common errors, so you need to append the mutable <code>mut</code> keyword to <code>let</code> in order to reassign a value – the compiler will warn you if there are unused <code>mut</code>s in your code.<br /><strong>Note: unlike C, for example, Rust does not let you edit an immutable variable </strong>via its pointer.</p>
<p>Speaking of type assignment, you can force the use of a particular type:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a: <span class="kw">uint</span> = <span class="dv">3</span>; <span class="co">// unsigned int</span>
<span class="kw">let</span> a = <span class="dv">3u</span>; <span class="co">// that&#39;s the same, using a short variable suffix for convenience</span>

<span class="kw">let</span> <span class="kw">mut</span> n = <span class="dv">3</span>; <span class="co">// `n` is supposedly an `int` here...</span>
n = <span class="dv">5u</span>; <span class="co">// but the compiler will infer it as an `uint` from here</span>
<span class="kw">let</span> <span class="kw">mut</span> h = ~[]; <span class="co">// unknown-type `vec` - won&#39;t compile as such</span>
h = ~[<span class="dv">1u</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// a `vec` of `uint`s</span></code></pre>
<p>There are other suffixes like <code>i32</code> (32-bit integer), <code>i64</code>, <code>f32</code> (32-bit float), <code>f64</code>… the empty type is called nil and annotated <code>()</code>. But remember, you cannot change the type of a variable during it’s lifetime – static typing!</p>
<p>Functions will need explicit parameters and return types through. Let’s look at one:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> square(x: <span class="kw">int</span>) -&gt; <span class="kw">int</span> {
    x*x
}

<span class="kw">fn</span> main() {
    <span class="kw">let</span> x = <span class="dv">3u</span>;
    <span class="co">/* Now, calculate the square. */</span>
    <span class="kw">let</span> y = square(x);
    <span class="ot">println!</span>(<span class="st">&quot;So this gives us {}.&quot;</span>, y);
}</code></pre>
<p>Ok, but this code will not typecheck because we are passing an unsigned int to a function that takes an int as parameter; if we were in a situation where we cannot change the type annotation, we would have to just cast the value of <code>x</code>.</p>
<p>Rust has various ways to change variable types, and while they all share different characteristics, they are also not all possible with all type combinations. Here is the general convention:</p>
<table>
<col style="width: 14%" /><col style="width: 15%" /><col style="width: 49%" /><col style="width: 20%" /><thead>
<tr class="header">
<th style="text-align: center;">cast</th>
<th style="text-align: center;"><code>.as_T()</code></th>
<th style="text-align: center;">ref change-no allocation ⇒ read-only</th>
<th style="text-align: center;"><code>&amp;'a T -&gt; &amp;'a U</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">conversion</td>
<td style="text-align: center;"><code>.to_T()</code> <code>.into_T()</code></td>
<td style="text-align: center;">allocates new memory “in-place” conversion, without copying</td>
<td style="text-align: center;"><code>&amp;T -&gt; ~U</code> <code>~T -&gt; ~U</code></td>
</tr>
</tbody>
</table>
<p>As you can see, <code>.as_T()</code> is normally just casting a reference so that it is treating the original data as if it were a different type (for example, the <code>.as_bytes</code> method allows the contents of a &amp;str to be viewed as a sequence of bytes, &amp;[u8]). A research on the <a href="http://static.rust-lang.org/doc/master/std/index.html">libstd documentation</a> will tell you which types implement which of these methods – in the present case, we would just use a <code>x as y</code> to cast between primitive types, in this case <code>x as uint</code>.</p>
<p>In Rust, instructions that do not end with semicolons are expressions (not statements), meaning that they will return their value to the higher-level block.<br />This allows you not only to return from a function but also – for example – to allocate a value based on a test’s result. This is valid Rust code:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hype =
    <span class="kw">if</span> cake == <span class="st">&quot;KitKat&quot;</span> {
        <span class="dv">10</span>
    } <span class="kw">else</span> <span class="kw">if</span> cake == <span class="st">&quot;Jelly Bean&quot;</span> {
        <span class="dv">7</span>
    } <span class="kw">else</span> {
        <span class="dv">5</span>
    };</code></pre>
</section>
<section id="a-last-note-on-types-and-prints" class="level2">
<h2>A last note on types and prints</h2>
<p>Let’s go back on a similar example as with the <code>spawn</code> before, this time using a <code>vec</code> of chars:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> out = [<span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>];
    <span class="kw">for</span> c in out.iter() { <span class="co">// iterate over `out`</span>
        <span class="ot">print!</span>(<span class="st">&quot;{}&quot;</span>, *c);
    }
}</code></pre>
<p>Rust supports UTF-8 (Unicode) natively through the <code>u8</code> type (8-bit unsigned type); strings are essentially just <code>~[u8]</code> arrays with a few specific methods on top of it.<br />FYI, there is a blog article that talks about types in Rust and has some interesting facts, <a href="http://jvns.ca/blog/2013/12/02/types-in-rust/">check it out</a>!</p>
<p>So Rust uses the <code>print!</code> and <code>println!</code> macros (also called syntax extensions, ending with <code>!</code>) in order to format-print your variables marked as <code>{}</code> and passed as arguments into strings.<br />Note that you can <a href="http://static.rust-lang.org/doc/master/std/fmt/index.html">specify the type manually</a>, e.g. <code>{:u}</code> means unsigned integer literal; this will permit compiler type-checking.<br />Also, <code>{:?}</code> will conveniently raw-print any kind of variable (in particular, arrays).</p>
</section>
<section id="appendix-going-back-on-macros" class="level2">
<h2>Appendix: Going back on macros</h2>
<p>Macros are defined as syntax extensions in the sense that they are like scripts, but are evaluated at <em>compile-time</em>. So they serve only the developer by simplifying/automating things.<br />Think about <code>#define</code> in C, but macros are much more powerful. Macros have a few syntax elements of their own; for example, variables get referenced with <code>$var</code>, so that you can differenciate macro variables – which serve “internally” – from actual, real Rust code.</p>
<p>Not elaborating further on it for now but you can have a look at the <a href="http://static.rust-lang.org/doc/master/tutorial-macros.html">mainline macro tutorial</a> for some code examples.</p>
</section>
<section id="appendix-on-functional-programming" class="level2">
<h2>Appendix: On functional programming</h2>
<p>Iterators <a href="http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html">have methods</a> such as <code>.map()</code>, <code>.zip()</code> and <code>.filter()</code> – a touch of functional programming which can combine and/or reuse iterator’s values in various ways. So one can write something like <code>iterator.map(...).zip(...)</code> which manages to apply a function to each of the iterator’s element (map) and append another iterator to it as a pair of elements (zip).</p>
<p>Here is an example using <a href="http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">fold</a>, which can combine an iterator’s values:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> xs = [<span class="dv">14</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">12</span>];

<span class="co">// this yields -35</span>
<span class="kw">let</span> result = xs.iter().fold(<span class="dv">0</span>, |accumulator, item| accumulator - *item);</code></pre>
<p>This approach is very practical as it keeps code concise and manages to do various kind of operations on variables quite easily.</p>
<p>Check out the <a href="http://static.rust-lang.org/doc/master/tutorial-container.html#iterators">iterators tutorial</a> to find out more.</p>
</section>
<section id="appendix-comments-and-documentation" class="level2">
<h2>Appendix: Comments and documentation</h2>
<p>You will probably start quickly adding comments to your code (well, you should anyways!) so let’s speak about that now: Rust uses C-style comments and also has a doc comments system (librustdoc) that’s quite similar to <a href="http://en.wikipedia.org/wiki/Javadoc">Javadoc</a>, for example.</p>
<table>
<col style="width: 13%" /><col style="width: 25%" /><col style="width: 28%" /><col style="width: 32%" /><thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;">Code comments</th>
<th style="text-align: center;">Global doc comments</th>
<th style="text-align: center;">Block-level doc comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">inline multiline</td>
<td style="text-align: center;"><code>// yuck!</code> <code>/* yuck! */</code></td>
<td style="text-align: center;"><code>//! foo</code> <code>/*! foo */</code></td>
<td style="text-align: center;"><code>/// bar</code> <code>/** bar */</code></td>
</tr>
</tbody>
</table>
<p>The built-in doc generator (librustdoc) will make pretty HTML documentation out of these: check out how it looks with the <a href="http://static.rust-lang.org/doc/master/std/index.html">libstd documentation</a>!<br />All comments accept the <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a> syntax and code snippets inside backticks, like so:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/*</span>
<span class="co"> * This file is part of my software,</span>
<span class="co"> * licensed under CC0 public domain license.</span>
<span class="co"> */</span>
<span class="co">//! Okay, this file is about providing an</span>
<span class="co">//! interface to the serial device I&#39;m using.</span>
<span class="co">//! All relevant functions are here.</span>

<span class="co">/// This functions returns the current status.</span>
<span class="co">/// true: ok</span>
<span class="co">/// false: err</span>
<span class="co">///</span>
<span class="co">/// # Example</span>
<span class="co">///</span>
<span class="co">/// ```</span>
<span class="co">/// if !reachable() {</span>
<span class="co">///     fail!(&quot;Device not responding!&quot;);</span>
<span class="co">/// }</span>
<span class="co">/// ```</span>
<span class="kw">fn</span> reachable() -&gt; <span class="kw">bool</span> {
    foo
}</code></pre>
<p>You can learn more about rustdoc intrinsics <a href="http://static.rust-lang.org/doc/master/rustdoc.html">here</a>.</p>
<p>Hmm, do you see that <code>fail!</code> macro in the example above?<br />It is part of a stack of debugging macros, we will have a look at that in the next chapter.</p>
</section>
</section>
<section id="testing-logging-matching-so-wirds-gemacht" class="level1">
<h1>Testing, Logging, Matching… so wird’s gemacht!</h1>
<p>It might seem a bit early to talk about those topics but it is a good spot for Rust because these features are often used while writing initial code. We will also talk about error handling, which you will encounter sooner or later as it is quite different from most of today’s programming languages.</p>
<p><small>This chapter will not discuss things like debugging running executables (e.g., with Valgrind).</small></p>
<section id="tests-and-linkage-attributes" class="level2">
<h2>Tests and linkage attributes</h2>
<p>Okay so first, Rust packs a built-in testing/benching framework – an approach that might seem familiar to people coming from Ruby.</p>
<p>In order to use it, you will need to preappend the <code>#[test]</code> compiler attribute (notice the # and brackets syntax) to a function that will serve as test.</p>
<p>Here is one:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
<span class="kw">fn</span> try_fetch() {
    <span class="kw">if</span> external::input() == -<span class="dv">1</span> {
        <span class="ot">fail!</span>(<span class="st">&quot;Couldn&#39;t retrieve the result!&quot;</span>);
    }
}</code></pre>
<p>These functions – just like blocks or statements marked with the <code>#[cfg(test)]</code> compiler attribute – will not be part of the default compiled code. This way, you can keep your files tidy by placing the tests relating to a specific part of your program at the bottom of the corresponding file.</p>
</section>
<section id="doing-it-wrong" class="level2">
<h2>Doing it wrong</h2>
<p>Test functions are blackboxes: they have no arguments nor returns.<br />Besides <code>fail!</code> that halts the program and displays the error message passed as argument, tests are often made of assertions: the <code>assert!</code> macro takes a boolean expression as parameter; it does nothing if it evaluates to true and fails when it’s false. <code>assert_eq!</code> is a variant takes 2 variables as parameters and asserts equality.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ascii::OwnedStrAsciiExt;

<span class="ot">#[</span>test<span class="ot">]</span>
<span class="kw">fn</span> lowercase_ascii() {
    <span class="kw">let</span> tmp = ~<span class="st">&quot;ME&quot;</span>;
    <span class="ot">assert_eq!</span>(~<span class="st">&quot;me&quot;</span>, tmp.into_ascii_lower());
}</code></pre>
<p>Now, we just have to call <code>rustc --test</code> with the name of our file, and run it.</p>
<p>That is how the output looks like (when everything is fine, that is):</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">running</span> 1 test

<span class="kw">test</span> lowercase_ascii ... ok

<span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
<p>There is also <code>#[bench]</code> for benchmarking certain functions. These features are largely used in the Rust compiler itself to avoid any regression during the development process.</p>
<p><strong>Note:</strong> if you are running your program in debugging mode (that is, with <code>RUST_LOG</code> cmdline parameter defined to level 1/2/3/4), <code>error!</code> <code>warn!</code> <code>info!</code> <code>debug!</code> will get triggered depending on the logging level.</p>
</section>
<section id="moving-on-about-error-handling" class="level2">
<h2>Moving on about error handling</h2>
<p>Rust does not have “opt-in” error handling (well, it trys to avoid opt-in safety measures when possible); that is, it works with the use of an <code>Option</code> wrapper directly in the function declaration.</p>
<p>Here are its possible values as defined in an <code>enum</code> (C-like cases enumerator):</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
    <span class="kw">Some</span>(T),
    <span class="kw">None</span>
}</code></pre>
<p><strong>Note:</strong> if you are coming from C++, you will recognize those <code>&lt;&gt;</code> which denote polymorphism, i.e. a method that applies to various variable types (<code>T</code> being a lambda type). We will go back on those notions and on the <code>trait</code> concept in a later chapter.</p>
<p>So, an <code>Option</code> type encapsulating a certain type of variable will return <code>Some()</code> if a value gets catched or <code>None</code> if nothing passes through it.</p>
<p>Now let’s go about doing error handling, what we must do is destructuring those types so that we can make use of the value if we get one and also handle the case where we would not get anything returned.</p>
<p>If you are a C user, you are probably thinking about the use of the <code>switch</code> pattern?<br />Well, Rust has a more powerful tool called <code>match</code>, for pattern matching.</p>
<p>The mainline Rust documentation has a good example to show its most basic innards:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> my_number {
    x <span class="kw">if</span> x &lt; <span class="dv">0</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;something lower than zero&quot;</span>),
    <span class="dv">0</span>          =&gt; <span class="ot">println!</span>(<span class="st">&quot;zero&quot;</span>),
    <span class="dv">1</span> | <span class="dv">2</span>      =&gt; <span class="ot">println!</span>(<span class="st">&quot;one or two&quot;</span>),
    <span class="dv">3.</span>.<span class="dv">10</span>      =&gt; <span class="ot">println!</span>(<span class="st">&quot;three to ten&quot;</span>),
    _          =&gt; <span class="ot">println!</span>(<span class="st">&quot;something else&quot;</span>)
}</code></pre>
<p>Something that must be noted is that <code>match</code> must handle all possible cases for it to compile.<br />The wildcard <code>_</code> means: “for all (other) possible cases”, so you will often have to use it as the last option, unless you are, for example, matching over all the individual components of an <code>enum</code>.</p>
<p>Here is how we would match against an <code>Option</code> value:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> optional_arg {
    <span class="kw">Some</span>(val) =&gt; val,
    <span class="kw">None</span> =&gt; () <span class="co">// `nil`, the empty type</span>
}</code></pre>
<p>If you remember, about assignments:</p>
<ul>
<li>We can assign a variable from a match statement, as shown before</li>
<li>Otherwise, the pattern above will behave as an expression, i.e. as if we had written a <code>return</code> statement</li>
</ul>
<p>We said that <code>match</code> was not the only way to destructure an <code>Option</code> type before, and there is another way involving Rust’s functional capatibilities.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> optional_arg: <span class="kw">Option</span>&lt;<span class="kw">int</span>&gt; = get_option_val();

<span class="co">// this will remove the `Option` wrapper,</span>
<span class="co">// i.e. return the value contained in `Some()` or fail</span>
optional_arg.unwrap();

<span class="co">// this will unwrap or fail with the specified message in the `None` case</span>
optional_arg.expect(<span class="st">&quot;No value returned!&quot;</span>);
<span class="co">// this will return the value passed as parameter when encountering `None`</span>
optional_arg.unwrap_or(<span class="dv">3</span>);</code></pre>
<p><strong>Note:</strong> as you can see, error handling is not a big deal in the sense that you can simply call an <code>.unwrap()</code> if you do not care much about the failing case.</p>
<p>This does not give you as much possibilities as with <code>match</code> but it covers the common use case of <code>Option</code>. There <a href="http://static.rust-lang.org/doc/master/std/option/enum.Option.html">is also</a> <code>.is_some()</code> or <code>.is_none()</code> if you want to do conditionals.</p>
</section>
<section id="appendix-getting-decent-results" class="level2">
<h2>Appendix: Getting decent <code>Result</code>s</h2>
<p>There is a variant to the <code>Option</code> type, called <code>Result</code>:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Result</span>&lt;T, E&gt; {
    <span class="kw">Ok</span>(T),
    <span class="kw">Err</span>(E)
}</code></pre>
<p>It is quite different from <code>Option</code>:</p>
<ul>
<li>As you can see, it returns an error message when it fails, which implies differences with <code>Option</code>…</li>
<li>In fact, <code>Result</code> will handle cases when computation errors can occur (and even allow you to do different things depending on the error message) while <code>Option</code> handles cases when an argument can be missing, it’s also used to pass NULL pointers to C, and so on…</li>
</ul>
<p>Similarly to <code>Option</code>, <code>Result</code> <a href="http://static.rust-lang.org/doc/master/std/result/enum.Result.html">has</a> the <code>is_ok()</code> and <code>is_err()</code> methods.</p>
</section>
<section id="appendix-can-you-match-it" class="level2">
<h2>Appendix: Can you <code>match</code> it?</h2>
<p>Pattern matching is pretty powerful, noticeably when coupled with the use of tuples.<br />Like in Python, tuples are heterogenous lists of elements (that is, with different, unsequenced element types).</p>
<p>Tuples come also in handy, for example, when returning multiple values from a function:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="co">// type is ambiguous here and needs to be annotated</span>
    <span class="kw">let</span> f: <span class="kw">f32</span> = <span class="dv">1.0e-2</span>;

    <span class="kw">let</span> (mantissa, exponent, sign) = f.integer_decode();
    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, mantissa);
}</code></pre>
<p>As an example, here is an implementation of <a href="http://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> using pattern matching:</p>
<blockquote>
<p>Print numbers from 1 to 100, but for multiples of three print “Fizz” instead and for the multiples of five print “Buzz”; for multiples of both print “FizzBuzz”.</p>
</blockquote>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">for</span> i in range(<span class="dv">0u</span>, <span class="dv">101</span>) {
        <span class="kw">match</span> (i % <span class="dv">3</span> == <span class="dv">0</span>, i % <span class="dv">5</span> == <span class="dv">0</span>) {
            (<span class="kw">true</span>, <span class="kw">true</span>)   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Fizz Buzz&quot;</span>),
            (<span class="kw">true</span>, <span class="kw">false</span>)  =&gt; <span class="ot">println!</span>(<span class="st">&quot;Fizz&quot;</span>),
            (<span class="kw">false</span>, <span class="kw">true</span>)  =&gt; <span class="ot">println!</span>(<span class="st">&quot;Buzz&quot;</span>),
            (<span class="kw">false</span>, <span class="kw">false</span>) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, i)
        }
    }
}</code></pre>
<p>If you want to see more on this, there is a <a href="http://composition.al/blog/2013/03/02/fizzbuzz-revisited/">whole article</a> about various ways to implement this program in Rust.</p>
<p><strong>Note:</strong> you can match through <code>ref x</code> instead of <code>x</code> to get a reference instead of a value (i.e. get a pointer referencing <code>x</code>) – some functions will need referencing.</p>
</section>
</section>
<section id="guess-what" class="level1">
<h1>Guess what…</h1>
<p>Okay, now let’s do some lab work. You should (almost) have the knowledge to implement a classic litle game: guessing a secret number.</p>
<blockquote>
<p>The computer (randomly) chooses a number between 1 and 100 and the user must find it; the computer will tell whether the given number is too low/high until the user finds the right one.</p>
</blockquote>
<p>Alright, let’s have some prerequisities beforehand.</p>
<p>The first thing we will need is to have a random number in our hands.</p>
<section id="getting-some-rng" class="level2">
<h2>Getting some RNG</h2>
<p>We want an integer random number, bounded between 1 and 100. Let’s print a few of them:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// `use` imports methods into namespace</span>
<span class="kw">use</span> std::rand::{task_rng, Rng};

<span class="kw">fn</span> main() {
    <span class="kw">let</span> <span class="kw">mut</span> cur;
    <span class="kw">for</span> _ in range(<span class="dv">0</span>, <span class="dv">11</span>) {
        <span class="co">// nb: range upper bound is exclusive</span>
        cur = task_rng().gen_range(<span class="dv">1u</span>, <span class="dv">101</span>);
        <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, cur);
    }
}</code></pre>
<p>Then, we will have to get input from the user. Unlike <code>print</code> and friends, input methods are not built in Rust programs by default, i.e. they are not in the prelude.</p>
</section>
<section id="importing-from-the-standard-library" class="level2">
<h2>Importing from the standard library</h2>
<p>So, we will have to import the relevant <code>std::io</code> methods manually, with the <code>use</code> keyword that is just like <code>import</code> in Python or Java. <code>#include</code> in C is quite similar too althrough C works only on a per-file basis.<br />Contrariwise, Rust uses the concept of module. Similarly to Java’s packages, each file is a module, but not only: you can declare modules with the <code>mod</code> keyword within a file, and each one has a different namespace, which means that you will have to go through logical paths (<code>::</code>) of modules when importing methods.</p>
<p>Module names are lowercase by convention.</p>
<p><strong>Note:</strong> modules are superseded by <code>crate</code>s, which are individual compilation units (one gets compiled at a time, e.g., one library on a project makes one crate).</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// We can select different functions with `{}`.</span>
<span class="co">// Note: `use` must precede `mod` statement.</span>
<span class="kw">use</span> foo::{bar, baz};

<span class="kw">mod</span> foo {
    <span class="kw">pub</span> <span class="kw">fn</span> bar();
    <span class="kw">pub</span> <span class="kw">fn</span> baz();
}

bar();
baz();

<span class="co">// Now, import `baz()` fn from `bonus.rs`.</span>
<span class="kw">mod</span> bonus;
bonus::baz();</code></pre>
<p><strong>Note:</strong> the <code>priv</code> and <code>pub</code> attributes permit to allow/disallow access to a specific module of function.</p>
<p>So, back to the stdio things:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::stdin;</code></pre>
<p>If you are looking for a specific function to import at some point, just look in <a href="http://static.rust-lang.org/doc/master/std/index.html">libstd documentation</a> or <a href="http://client01.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">ask your way on IRC</a>.</p>
<p><strong>Note:</strong> if you wanted to import from external libraries you would have to link to them using <code>extern crate</code>. For example, the Rust filestack has an <code>extra</code> library for non-core things, which you could link to using <code>extern crate extra;</code> before your <code>use</code> statement.</p>
</section>
<section id="calling-the-user-err" class="level2">
<h2>Calling the user… err?</h2>
<p>Alright, now let’s call <code>read_line()</code> to get input from the user. This method makes use of the <code>Option</code> type we just saw.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::BufferedReader;
<span class="kw">use</span> std::io::stdin;

<span class="kw">fn</span> main() {
    <span class="ot">println!</span>(<span class="st">&quot;Type something:&quot;</span>);

    <span class="kw">let</span> <span class="kw">mut</span> reader = BufferedReader::new(stdin());

    <span class="co">// Note: input will end with `\n`</span>
    <span class="kw">match</span> reader.read_line() {
        <span class="co">// Handle empty input too</span>
        <span class="kw">Some</span>(~<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) =&gt; <span class="ot">println!</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">I never asked for this...&quot;</span>),
        <span class="kw">Some</span>(thing) =&gt; <span class="ot">println!</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">You typed: {}&quot;</span>, thing),
        <span class="kw">None</span>        =&gt; <span class="ot">println!</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Well, that&#39;s unexpected!&quot;</span>)
    }
}</code></pre>
<p>On a side note: if you want a message and an input on the same line, it will take a direct access to <code>stdout</code>.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::stdout;

stdout.write(<span class="st">&quot;Type something: &quot;</span>.as_bytes());
<span class="ot">println!</span>(reader.read_line().unwrap());</code></pre>
<p>Now we want to get an int out of <code>stdin</code>, but looking at the empty case, the program could behave strangely depending on what we are doing with it. So instead we could ask the user back for input (by a recursive call to our input function, for example) or stop with a specific error message.<br />Here is an example that uses a <code>loop</code>:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::stdin;

<span class="kw">fn</span> number_input() {
    <span class="ot">println!</span>(<span class="st">&quot;Please type a number: &quot;</span>);

    <span class="kw">loop</span> {
        <span class="co">// We need to trim the EOL `\n` char to be able to convert</span>
        <span class="kw">match</span> from_str::&lt;<span class="kw">uint</span>&gt;(stdin().read_line().trim_right_chars(&amp;<span class="ch">&#39;\n&#39;</span>)) {
            <span class="kw">Some</span>(x) =&gt; <span class="kw">return</span> x,
            <span class="kw">None</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;I&#39;d rather have a number.&quot;</span>)
        }
    }
}</code></pre>
<p>Okay, that should be all you need. Just do it by yourself and the compiler outputs first before looking at the doc!</p>
<p>Let’s add something to the game: we will count how many times the user tries and display it at the end.</p>
</section>
<section id="the-solution-well-an-implementation-of-it" class="level2">
<h2>The Solution (well, an implementation of it)</h2>
<p>So here it is:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::BufferedReader;
<span class="kw">use</span> std::io::stdin;
<span class="kw">use</span> std::rand::{task_rng, Rng};

<span class="kw">fn</span> input_line() -&gt; ~<span class="kw">str</span> {
    <span class="kw">let</span> <span class="kw">mut</span> reader = BufferedReader::new(stdin());
    <span class="kw">loop</span> {
        <span class="kw">match</span> reader.read_line() {
            <span class="kw">Some</span>(~<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) =&gt; <span class="ot">println!</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Uhm, please type something...&quot;</span>),
            <span class="kw">Some</span>(thing) =&gt; <span class="kw">return</span> thing,
            <span class="kw">None</span> =&gt; <span class="kw">continue</span>
        }
    }
}

<span class="kw">fn</span> input_number() -&gt; <span class="kw">uint</span> {
    <span class="ot">println!</span>(<span class="st">&quot;Please type a number: &quot;</span>);

    <span class="kw">loop</span> {
        <span class="kw">match</span> from_str::&lt;<span class="kw">uint</span>&gt;(input_line().trim_right_chars(&amp;<span class="ch">&#39;\n&#39;</span>)) {
            <span class="kw">Some</span>(x) =&gt; <span class="kw">return</span> x,
            <span class="kw">None</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;I&#39;d rather have a number.&quot;</span>)
        }
    }
}

<span class="kw">fn</span> main() {
    <span class="ot">println!</span>(<span class="st">&quot;The computer is choosing a secret number, between 1 and 100...&quot;</span>);
    <span class="kw">let</span> nbr = task_rng().gen_range(<span class="dv">1u</span>, <span class="dv">101</span>);
    <span class="kw">let</span> <span class="kw">mut</span> cpt = <span class="dv">0u</span>;

    <span class="ot">println!</span>(<span class="st">&quot;Can you guess it?&quot;</span>);
    <span class="kw">loop</span> {
        cpt += <span class="dv">1</span>;
        <span class="kw">match</span> input_number() {
            x <span class="kw">if</span> x &lt; nbr =&gt; <span class="ot">println!</span>(<span class="st">&quot;Too low!&quot;</span>),
            x <span class="kw">if</span> x &gt; nbr =&gt; <span class="ot">println!</span>(<span class="st">&quot;Too high!&quot;</span>),
            _ =&gt; { <span class="ot">println!</span>(<span class="st">&quot;Yes, you found it in {} tries!&quot;</span>, cpt); <span class="kw">break</span>; }
        }
    }
}</code></pre>
<p>We have <code>input_line()</code> that takes a non-empty stdin input and <code>input_number()</code> that ensures a non-empty converted number.</p>
</section>
</section>
<section id="getting-some-pointers" class="level1">
<h1>Getting some pointers</h1>
<p>Rust is quite particular when it comes to pointers: it keeps a high-performance scheme while ensuring safety use patterns (no dangling pointers, etc.).</p>
<p>We will also talk about <em>ownership</em> and <em>lifetimes</em> in this chapter.</p>
<section id="introduction" class="level2">
<h2>Introduction</h2>
<p>First, let’s look for a second at how things are laid out in memory. There are two important <a href="http://stackoverflow.com/a/1213360">memory pools</a>, the <strong>stack</strong> and the <strong>heap</strong>.</p>
<section id="simply-put" class="level3">
<h3>Simply put</h3>
<p>Functions are individual, reusable pieces of code. If we want to directly edit a variable from the originating (caller) namespace, we need to pass its memory address, i.e. a pointer to the said variable so that the function knows where to find it and access it.</p>
<p><small>Also, when passing huge structures of data you might want to pass a pointer to it to save on memory copies but that is a quite sparse use-case as we will see.</small></p>
</section>
<section id="on-stack-and-heap" class="level3">
<h3>On stack, and heap</h3>
<p>Each application uses a pool of memory called the <strong>stack</strong>, of fixed-size, allocated when a task starts up. There are various mechanisms occuring inside the stack but it is mostly hosting all <em>local variables</em> and parameters used along the execution. When a function is called, the existing registers are saved on memory and the program jumps to the function and creates a new stack frame for it. The stack also traces the order in which functions are called so that function returns occur correctly. The default stack size of a Rust task is 2 MiB.<br />So, we need to pass a memory address in order to be able to edit a variable from the caller’s namespace – that is the main reason why we use pointers.</p>
<p>A program can also dynamically request memory with the unused memory in the computer, managed by the OS: this is called the <strong>heap</strong>. All dynamically-sized types (DST) are stored on the heap with an OS allocation.<br />The heap can only be accessed via a pointer located on the stack since it is not the default memory pool, these pointers create a <strong>box</strong>.</p>
<p>So, an <code>int</code> has a fixed-size in memory and is stack-allocated. A dynamic-array <code>~[]</code>, a string <code>~str</code> or anything <code>~</code> is allocated on the heap (that is where you would use <code>malloc</code> in C or <code>new</code> in C++).</p>
</section>
</section>
<section id="different-kinds" class="level2">
<h2>Different kinds</h2>
<p>Rust has two primary pointer types: the borrowed reference (using the <code>&amp;</code> symbol) and the owned pointer (indicated by <code>~</code>).</p>
<section id="referencing" class="level3">
<h3>Referencing</h3>
<p>Referencing is also called borrowing because creating a reference freezes the target variable, i.e. it cannot be freed nor transfered (so no use-after-free). When the reference gets out of scope and freed, it is available again to the caller. References use the <code>&amp;</code> operator, just like C pointers; or <code>&amp;mut</code> with mutability, which need to point to uniquely referenced, mutable data – everything is statically checked.</p>
<p>This would be the most basic example:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">3</span>;
{
    y = &amp;x; <span class="co">// `x` is now frozen and cannot be modified</span>
    <span class="co">// ...but it can be read since the borrow is immutable</span>
}
<span class="co">// `x` can be accessed again (`y` is out of scope)</span></code></pre>
<p>A borrow cannot outlive the variable it originates from: it has a <strong>lifetime</strong>, meaning that you will have to change your allocation pattern if a reference outlives its lifetime, like here:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = &amp;<span class="dv">3</span>;
{
    <span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">4</span>;
    x = &amp;y;
} <span class="co">// `y` is freed here, but `x` still lives...</span></code></pre>
<p>This pattern will be rejected, since <code>y</code> has a shorter lifetime than <code>x</code>.<br />The compiler enforces valid references and yields:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">error</span>: borrowed value does not live long enough</code></pre>
<p><strong>Note:</strong> there are a few cases through like when returning a reference passed to a function where you will need to add a lifetime annotation, so that it is inferred from the caller; more on that a bit later.</p>
<p>Referencing is the default choice as a pointer: all checks are performed at compile-time (by the borrow checker) so its footprint is that of a C pointer (which is also available in Rust as <code>unsafe</code>, <code>*</code> pointer).<br />The unary star operator <code>*</code> also serves for dereferencing, like in C.</p>
</section>
<section id="unique-ownership" class="level3">
<h3>Unique ownership</h3>
<p>An owned pointer owns a certain (dynamically allocated) part of the heap, i.e. the owner is the only one who can access the data – unless it transfers ownership, at which point the compiler will free the memory automatically (pointer is copied, but not the value).</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take&lt;T&gt;(ptr: ~T) { <span class="co">// works for any type, `T`</span>
    ...
}

<span class="kw">let</span> m = ~<span class="st">&quot;Hello!&quot;</span>;
take(m);
take_again(m); <span class="co">// ERROR: `m` is moved</span></code></pre>
<p>Note that owned pointers can, like most objects, be borrowed. You can also copy a unique pointer using <code>.clone()</code>, but this is an expensive operation.</p>
</section>
<section id="shared-pointers" class="level3">
<h3>Shared pointers</h3>
<p>“Shared” may evoke Garbage Collection to you. Well, this is partly the case.</p>
<p>Using only owned and borrowed pointers, ownership forms a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>, while shared pointers allow multiple pointers to the same object and cycles. There are few of them, either GC-managed (with immutability to prevent data races), or Reference counted with specific types that allow thread-sharing or mutability, for instance. Note that Rust also has, of course, mutable shared pointer types.</p>
<p><strong>Note:</strong> As you can see, these pointers serve a particular purpose. You should not have to look at them until they are needed in one of your programs.</p>
<p>First and foremost, please note that the new tracing, task-local Garbage Collection algorithm that will be introduced into the standard library is being worked on right now.<br />So, there used to be an <code>@</code> managed pointer type, but it has been phased out in favor of <code>std::rc::Rc</code> and <code>std::gc::Gc</code>; which are standard library types. Right now, <code>Gc</code> is just a wrapper around <code>Rc</code>, which manually counts references, meaning less overhead than a GC algorithm (which periodically checks for pointer references) but it has a few limitations, e.g. it will leak memory on cycles (recursive data structures and the likes).</p>
<p><strong>Note:</strong> task-local (or per-thread) GC is an important part of the deal because it means that you can have a task which handles low-latency jobs and is manually managed and another that can just run GC; task local also means that you can’t pass these pointers between tasks, which can be desired in some cases.</p>
<p>Okay, let’s have a look at some of these “smart pointers”:</p>
<ul>
<li>First, if we want mutability inside of our <code>Gc</code>/<code>Rc</code> types, we will have to use <code>Cell</code> or <code>RefCell</code>, depending on whether the contained type is <code>Pod</code> or not (<code>Pod</code> is whatever type can be copied with a <code>memcpy</code> instruction, i.e. bool, integers, floats, char, <code>&amp;</code>/<code>*</code> and all types that are construction of these all): <code>Pod</code> can use <code>Cell</code>, everything else will use <code>RefCell</code>.<br /> You can see <code>Pod</code> as every type that has a fixed size and where you do not need to dereference it in order to access the content (that includes <code>struct</code> of <code>Pod</code> types, tuples, etc. but not dynamic vectors for instance).</li>
<li>We have said that <code>Gc</code> uses immutable, thread-local data. If we want to share data <strong>across threads</strong>, we would have to use a variant of <code>Rc</code>: <code>Arc</code>, i.e. <em>Atomically Reference Counted</em>. As the name suggests, it will make RefCount an atomic (insecable) operation (using <a href="http://en.wikipedia.org/wiki/Fetch-and-add">Fetch-and-add</a> on modern processors) so that it avoids data races where threads would access/modify the count at the same time.</li>
<li>What if we want <strong>cross-thread mutability</strong>? <code>Arc&lt;Cell&lt;&gt;&gt;</code> is not allowed since it would break atomicity, so there is a special type for that: <code>MutexArc</code>, internally using mutexes to prevent data races.<br /> There is a variant called <code>RWArc</code> that uses a <a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers–writer lock</a>, making it more efficient in the case where you have lots of readers.</li>
</ul>
</section>
</section>
<section id="the-edge-cases" class="level2">
<h2>The Edge-cases</h2>
<section id="references-and-lifetimes" class="level3">
<h3>References and lifetimes</h3>
<p>Okay, let’s use a silly example involving a function return:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take(x: &amp;<span class="kw">int</span>) -&gt; &amp;<span class="kw">int</span> {
    x
}

<span class="kw">fn</span> main() {
    <span class="kw">let</span> x = <span class="dv">4</span>;
    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, *take(&amp;x));
}</code></pre>
<p>You are probably thinking that <code>x</code> outlives its lifetime; that’s where it is:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">error</span>: cannot infer an appropriate lifetime due to conflicting requirements</code></pre>
<p>It doesn’t end there through, since we can pass a lifetime parameter from the caller to the function:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take&lt;<span class="ot">&#39;a</span>&gt;(ptr: &amp;<span class="ot">&#39;a</span> <span class="kw">int</span>) -&gt; &amp;<span class="ot">&#39;a</span> <span class="kw">int</span> {
    ptr
}

<span class="kw">fn</span> main() {
    <span class="kw">let</span> x = <span class="dv">4</span>;
    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, *take(&amp;x));
}</code></pre>
<p>As you can see here, we define <code>'a</code> as a parameter (the single quotation mark prefix denoting a lifetime), and annotate it to both the value being passed and the return value. In short, the return value will inherit the lifetime of the parameter.<br />Since <code>x</code> is still alive until the end of <code>main()</code> – the caller function, this pattern is valid and typechecks.</p>
<p>So generally speaking, if you want to return a borrowed value (eventually with a condition evaluation for instance), you will have to use that.<br />This is particularly useful if you want to modify a variable in-place (that is, without having to pass it as heap pointer), in which case you can take a mutable borrow <code>&amp;mut</code> with a lifetime annotation.</p>
<p>You can also annotate lifetime parameters to several variables, in which case the compiler will pick the lowest. This is useful when your output depends on a few variables:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> max&lt;<span class="ot">&#39;a</span>&gt;(x: &amp;<span class="ot">&#39;a</span> <span class="kw">int</span>, y: &amp;<span class="ot">&#39;a</span> <span class="kw">int</span>) -&gt; &amp;<span class="ot">&#39;a</span> <span class="kw">int</span> {
    <span class="kw">if</span> (*x &gt;= *y) {
        x
    } <span class="kw">else</span> {
        y
    }
}</code></pre>
<p>Lastly, there is a <code>'static</code> lifetime, which you want to use outside of any brace scope and does not expire. As an example, here is how rust defines its bug report URL string:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> BUG_REPORT_URL: &amp;<span class="ot">&#39;static</span> <span class="kw">str</span> = <span class="st">&quot;...url...&quot;</span>;</code></pre>
</section>
</section>
</section>
<footer>
<p>A Rust community project. [<a href="https://github.com/adrientetar/rust-tuts/graphs/contributors">&copy;</a>] <span class="pull-right"><a href="http://www.reddit.com/r/rust">Reddit</a> &middot; <a href="http://www.rust-lang.org/">Rustlang</a></span></p>
</footer>
</body>
</html>
